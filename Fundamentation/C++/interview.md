# C++

#### C++的内存管理
* **内存分配方式**
    在C++中，内存一般分成5个区，即堆、栈、自由存储区、全局/静态存储区和常量存储区。
    **栈 :** 函数执行过程的局部变量存储空间。
    **堆 :** `new`运算符操作的内存空间。
    **自由存储区 :** `malloc`函数操作的内存空间。
    **全局/静态存储区 :** 全局变量和静态变量存储空间。
    **常量存储区 :** 常量的存储空间
* **内存泄露及解决办法**
    程序分配的内存未能释放；内存泄漏并非物理内存消失，而是失去分配内存的控制。
    1. `new/malloc`申请资源后没有使用`delete/free`释放。
    2. 拷贝/赋值构造过程中进行`浅拷贝`。
    3. 有子类继承的父类析构函数没有定义为`虚函数`。

    **解决办法 :** 通过`对象`管理资源；使用`智能指针`。

#### 堆和栈的区别
* **空间分配机制不同 :** 栈是由`编译器`自动分配和释放；堆是程序员通过`new`和`delete`进行空间分配和释放的。
* **缓存方式不同 :** 栈使用的是`一级缓存`,生命周期结束立即释放；堆使用`二级缓存`,速度会慢些。

* **数据结构不同 :** 栈即栈结构，先进后出；堆类似数组结构。
* **地址生长方向不同 :** 堆是`向上增长`，低地址向高地址；栈是`向下增长`，高地址向低地址。

#### new和malloc的区别
* `new`是运算符，可以重载；申请内存无需显式指定内存大小，内存分配失败抛出`bac_alloc`异常；会自动调用类的构造函数和析构函数；
* `malloc`是标准库函数，申请内存需要显式指定内存大小，内存分配失败返回`nullptr`。

#### 智能指针和普通指针的区别
智能指针本质是`template class`，秉行以对象管理资源方式，使得资源通过类的构造函数获取和析构函数释放，避免内存泄漏。

**智能指针 `defined in the header <memory>`**
* `unique_ptr`实现严格拥有概念，保证同一时间只有一个智能指针指向该对象。**该指针不支持拷贝/赋值构造，但可以移动构造/赋值。**
* `shared_ptr`实现共享式拥有概念，允许多个智能指针指向该对象。实现机制是**拷贝构造时使用同一份引用计数。**
* `weak_ptr`辅助智能指针，主要为了解决`shared_ptr`中循环引用导致引用计数始终不为0而造成内存泄漏。实现机制是**只是单纯访问对象，构造和析构时都不会改变引用计数。**

注：A `weak_ptr` is created as a copy of a `shared_ptr`; 无法直接通过 `weak_ptr` access to 共享 object; `weak_ptr` 提供了一个 lock 方法，始终返回一个 `shared_ptr` 实例。

#### vector底层实现机制
`vector`底层是**动态数组**，主要通过`start`、`finish`和`end_of_storage`三个迭代器进行内存操作。
> size(): finish - start;
capacity(): end_of_storage - start;

**vector内存增长机制 :** 当空间不够时，会自动申请1.5/2.0倍原空间大小的内存，再把原内容拷贝过来，然后才开始构造新元素并释放原空间。因此任何引起vector容器空间重新分配的操作都会使原迭代器失效。

**vector中reserve()和resize()的区别 :** `reserve()`改变的是vector容器的`capacity`；`resize()`改变的是vector容器的`size`。



